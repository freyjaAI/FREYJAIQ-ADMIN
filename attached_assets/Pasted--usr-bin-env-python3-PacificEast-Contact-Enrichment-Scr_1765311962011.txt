#!/usr/bin/env python3
"""
PacificEast Contact Enrichment Script
Queries all four PacificEast APIs to pull phone, email, and address data for an individual.

APIs Used:
- DataPrime: Address verification, NCOA, identity verification
- Forward Phone Append (FPA): Phone number lookup
- Email Append (EMA): Email lookup
- Email Validation (EMV): Validate found emails

Usage:
    python pacificeast_lookup.py --key YOUR_ACCOUNT_KEY
    
    Or set environment variable:
    export PACIFICEAST_KEY=your_key
    python pacificeast_lookup.py
"""

import requests
import json
import argparse
import os
from urllib.parse import quote
from dataclasses import dataclass
from typing import Optional
import time


# =============================================================================
# CONFIGURATION
# =============================================================================

@dataclass
class Contact:
    first_name: str
    last_name: str
    address: str
    city: str
    state: str
    postal_code: str = ""
    address2: str = ""


# Target individual
TARGET = Contact(
    first_name="STEPHEN",
    last_name="KATZENBERGER",
    address="23625 N SANCTUARY CLUB DR",
    city="KILDEER",
    state="IL",
    postal_code="60047"
)


# API Endpoints (Development)
ENDPOINTS = {
    "dataprime": "https://dev-api.idicia.com/Services/NameAddress/DataPrime/1_1/dataprime.svc",
    "fpa": "https://dev-api.idicia.com/Services/Forward/Append/1_1/Append.svc",
    "ema": "https://dev-api.idicia.com/Services/Email/Append/1_3/Append.svc",
    "emv": "https://dev-api.idicia.com/Services/Email/Validation/1_1/emailvalidation.svc"
}


# =============================================================================
# API CLIENT
# =============================================================================

class PacificEastClient:
    def __init__(self, account_key: str):
        self.account_key = account_key
        self.session = requests.Session()
        self.session.headers.update({
            "X-PacificEast-Acct": account_key,
            "Accept": "application/json"
        })
    
    def _get(self, url: str) -> dict:
        """Make GET request and return JSON response."""
        print(f"\n  ‚Üí GET {url[:100]}...")
        try:
            resp = self.session.get(url, timeout=30)
            print(f"  ‚Üê Status: {resp.status_code}")
            
            if resp.status_code == 403:
                return {"status": -1, "errorInfo": {"code": 1, "description": "Unauthorized - check your API key"}}
            
            try:
                data = resp.json()
                return data
            except json.JSONDecodeError:
                return {"status": -1, "errorInfo": {"code": -1, "description": f"Invalid JSON response: {resp.text[:200]}"}}
                
        except requests.exceptions.RequestException as e:
            return {"status": -1, "errorInfo": {"code": -1, "description": str(e)}}

    # -------------------------------------------------------------------------
    # DataPrime - Address Verification & Identity
    # -------------------------------------------------------------------------
    def dataprime_lookup(self, contact: Contact) -> dict:
        """
        Query DataPrime for address verification and identity confirmation.
        Returns corrected address, NCOA info, historical addresses, deceased flag.
        """
        # REST format: /DataPrime.svc/{lastName}?firstName=...&address1=...
        url = (
            f"{ENDPOINTS['dataprime']}/{quote(contact.last_name)}"
            f"?firstName={quote(contact.first_name)}"
            f"&address1={quote(contact.address)}"
            f"&city={quote(contact.city)}"
            f"&state={quote(contact.state)}"
            f"&accountKey={quote(self.account_key)}"
        )
        
        if contact.postal_code:
            url += f"&postalCode={quote(contact.postal_code)}"
        if contact.address2:
            url += f"&address2={quote(contact.address2)}"
            
        return self._get(url)

    # -------------------------------------------------------------------------
    # Forward Phone Append - Phone Number Lookup
    # -------------------------------------------------------------------------
    def phone_lookup(self, contact: Contact, query_type: int = 0, include_first_name: bool = True) -> dict:
        """
        Query FPA for phone numbers.
        
        query_type:
            0 = Standard
            1 = Prioritize landline
            2 = Prioritize wireless
        """
        # REST format: /Append.svc/{queryType}?lastName=...&address=...
        url = (
            f"{ENDPOINTS['fpa']}/{query_type}"
            f"?lastName={quote(contact.last_name)}"
            f"&address={quote(contact.address)}"
            f"&city={quote(contact.city)}"
            f"&state={quote(contact.state)}"
        )
        
        if include_first_name and contact.first_name:
            url += f"&firstName={quote(contact.first_name)}"
        if contact.postal_code:
            url += f"&postalCode={quote(contact.postal_code)}"
            
        return self._get(url)

    def phone_lookup_with_fallback(self, contact: Contact) -> dict:
        """
        Try progressively looser queries to find phone numbers.
        Returns best result found.
        """
        strategies = [
            {"desc": "Full name + full address", "include_first": True, "use_zip": True, "use_city": True},
            {"desc": "Last name only + full address (household)", "include_first": False, "use_zip": True, "use_city": True},
            {"desc": "Full name + ZIP only", "include_first": True, "use_zip": True, "use_city": False},
            {"desc": "Full name + city/state only", "include_first": True, "use_zip": False, "use_city": True},
        ]
        
        for strategy in strategies:
            print(f"\n  Trying: {strategy['desc']}")
            
            # Build modified contact for this strategy
            modified = Contact(
                first_name=contact.first_name if strategy["include_first"] else "",
                last_name=contact.last_name,
                address=contact.address,
                city=contact.city if strategy["use_city"] else "",
                state=contact.state if strategy["use_city"] else "",
                postal_code=contact.postal_code if strategy["use_zip"] else ""
            )
            
            # Try all three query types
            for qt in [0, 2, 1]:  # Standard, then wireless priority, then landline
                result = self.phone_lookup(modified, query_type=qt, include_first_name=strategy["include_first"])
                
                if result.get("status") == 0 and result.get("lookupResult") == 1:
                    result["_strategy"] = strategy["desc"]
                    result["_query_type"] = qt
                    return result
                    
                time.sleep(0.2)  # Small delay between requests
        
        return {"status": 0, "lookupResult": 0, "message": "No phone found with any strategy"}

    # -------------------------------------------------------------------------
    # Email Append - Email Lookup
    # -------------------------------------------------------------------------
    def email_lookup(self, contact: Contact, query_type: str = "Individual") -> dict:
        """
        Query EMA for email addresses.
        
        query_type:
            "Individual" - Only accept individual-level match
            "Household" - Accept household or individual match
        """
        # REST format: /Append.svc/{queryType}?lastName=...&address=...&purpose=FR
        url = (
            f"{ENDPOINTS['ema']}/{quote(query_type)}"
            f"?lastName={quote(contact.last_name)}"
            f"&address={quote(contact.address)}"
            f"&city={quote(contact.city)}"
            f"&state={quote(contact.state)}"
            f"&purpose=FR"
        )
        
        if contact.first_name:
            url += f"&firstName={quote(contact.first_name)}"
        if contact.postal_code:
            url += f"&postalCode={quote(contact.postal_code)}"
            
        return self._get(url)

    def email_lookup_with_fallback(self, contact: Contact) -> dict:
        """Try Individual first, then Household match."""
        # Try individual match first
        print("\n  Trying: Individual match")
        result = self.email_lookup(contact, query_type="Individual")
        
        if result.get("status") == 0 and result.get("lookupResult") == 1:
            result["_match_type_requested"] = "Individual"
            return result
        
        # Fall back to household match
        print("\n  Trying: Household match")
        time.sleep(0.2)
        result = self.email_lookup(contact, query_type="Household")
        
        if result.get("status") == 0 and result.get("lookupResult") == 1:
            result["_match_type_requested"] = "Household"
            return result
            
        return {"status": 0, "lookupResult": 0, "message": "No email found"}

    # -------------------------------------------------------------------------
    # Email Validation - Validate Found Emails
    # -------------------------------------------------------------------------
    def validate_email(self, email: str) -> dict:
        """
        Validate an email address for deliverability.
        
        Returns deliverability score, domain type, and can correct typos.
        """
        # REST format: /emailvalidation.svc/{email}?purpose=FR
        # Note: @ must be encoded as %40
        encoded_email = quote(email, safe='')
        url = f"{ENDPOINTS['emv']}/{encoded_email}?purpose=FR"
        
        return self._get(url)


# =============================================================================
# RESULT FORMATTERS
# =============================================================================

def format_dataprime_result(result: dict) -> None:
    """Pretty print DataPrime results."""
    print("\n" + "="*70)
    print("DATAPRIME - Address Verification & Identity")
    print("="*70)
    
    if result.get("status") == -1:
        error = result.get("errorInfo", {})
        print(f"‚ùå Error: {error.get('description', 'Unknown error')}")
        print(f"   Code: {error.get('code')}")
        return
    
    if result.get("lookupResult") != 1:
        print("‚ùå No match found")
        return
    
    # Address action interpretation
    address_actions = {
        0: "‚úÖ Input address is valid/best",
        1: "üìù Address was corrected",
        2: "üì¨ NCOA - Person moved (forwarding address found)",
        3: "üì¨ Non-NCOA move detected",
        4: "‚ö†Ô∏è  NCOA match but undeliverable (NIXIE)",
        5: "üì¨ NCOA match on corrected address",
        6: "‚ö†Ô∏è  Moved, no forwarding address (MLNA)",
        7: "‚ö†Ô∏è  Moved from corrected address, no forwarding (MLNA)",
        8: "‚ö†Ô∏è  Moved from corrected address, undeliverable (NIXIE)"
    }
    
    action = result.get("addressAction", -1)
    print(f"\nAddress Status: {address_actions.get(action, f'Unknown ({action})')}")
    print(f"Identity Verified: {'‚úÖ Yes' if result.get('verifiedIdentity') else '‚ùå No'}")
    print(f"Known Deceased: {'‚ö†Ô∏è  YES' if result.get('knownDeceased') else '‚úÖ No'}")
    
    if result.get("dob"):
        print(f"Date of Birth: {result.get('dob')}")
    
    # Addresses
    addresses = result.get("addresses", [])
    if addresses:
        print(f"\nüìç Addresses Found ({len(addresses)}):")
        for i, addr in enumerate(addresses, 1):
            current = "üè† CURRENT" if addr.get("isMostRecent") else "üìú Historical"
            print(f"\n  [{i}] {current}")
            print(f"      {addr.get('address1', '')} {addr.get('address2', '')}".strip())
            print(f"      {addr.get('city', '')}, {addr.get('state', '')} {addr.get('postalCode', '')}")
            print(f"      Dwelling: {addr.get('dwellingType', 'Unknown')} | Delivery Score: {addr.get('deliveryScore', 'N/A')}")
            if addr.get("effectiveDate"):
                print(f"      Effective: {addr.get('effectiveDate')}")
            if addr.get("isCMRA"):
                print(f"      ‚ö†Ô∏è  CMRA (Commercial Mail Receiving Agency)")
    
    # Names
    names = result.get("names", [])
    if names:
        print(f"\nüë§ Name Variations ({len(names)}):")
        for name in names:
            full = name.get("fullName") or f"{name.get('firstName', '')} {name.get('middleName', '')} {name.get('lastName', '')}".strip()
            print(f"      {full}")


def format_phone_result(result: dict) -> None:
    """Pretty print FPA results."""
    print("\n" + "="*70)
    print("FORWARD PHONE APPEND - Phone Numbers")
    print("="*70)
    
    if result.get("status") == -1:
        error = result.get("errorInfo", {})
        print(f"‚ùå Error: {error.get('description', 'Unknown error')}")
        print(f"   Code: {error.get('code')}")
        return
    
    if result.get("lookupResult") != 1:
        print(f"‚ùå No phone numbers found")
        if result.get("message"):
            print(f"   {result.get('message')}")
        return
    
    if result.get("_strategy"):
        print(f"Strategy Used: {result.get('_strategy')}")
        qt_names = {0: "Standard", 1: "Landline Priority", 2: "Wireless Priority"}
        print(f"Query Type: {qt_names.get(result.get('_query_type'), result.get('_query_type'))}")
    
    contacts = result.get("contacts", [])
    match_infos = result.get("matchInfo", [])
    
    print(f"\nüìû Contacts Found ({result.get('contactsFound', len(contacts))}):")
    
    for i, contact in enumerate(contacts):
        phone_info = contact.get("phoneInformation", {})
        name_info = contact.get("nameInformation", {})
        addr_info = contact.get("addressInformation", {})
        
        # Get match scores if available
        match = match_infos[i] if i < len(match_infos) else {}
        
        phone = phone_info.get("phoneNumber", "N/A")
        if len(phone) == 10:
            phone = f"({phone[:3]}) {phone[3:6]}-{phone[6:]}"
        
        contact_type = {"R": "Residential", "B": "Business", "BR": "Business/Residential"}.get(
            phone_info.get("contactType", ""), "Unknown"
        )
        
        print(f"\n  [{i+1}] üì± {phone}")
        print(f"      Type: {contact_type}")
        print(f"      Source: {phone_info.get('source', 'Unknown')}")
        
        name = f"{name_info.get('firstName', '')} {name_info.get('lastName', '')}".strip()
        if name_info.get("businessName"):
            name += f" ({name_info.get('businessName')})"
        if name:
            print(f"      Name: {name}")
        
        addr = f"{addr_info.get('address', '')} {addr_info.get('unit', '')}".strip()
        if addr:
            print(f"      Address: {addr}")
            print(f"               {addr_info.get('city', '')}, {addr_info.get('state', '')} {addr_info.get('postalCode', '')}")
        
        if phone_info.get("startDate"):
            print(f"      Start Date: {phone_info.get('startDate')}")
        
        # Match confidence
        if match:
            name_score = match.get("overallName", -1)
            addr_score = match.get("overallAddress", -1)
            score_labels = {-1: "N/A", 0: "None", 2: "Low", 8: "High", 10: "Exact"}
            print(f"      Match Confidence: Name={score_labels.get(name_score, name_score)}, Address={score_labels.get(addr_score, addr_score)}")


def format_email_result(result: dict, validation_result: Optional[dict] = None) -> None:
    """Pretty print EMA results."""
    print("\n" + "="*70)
    print("EMAIL APPEND - Email Address")
    print("="*70)
    
    if result.get("status") == -1:
        error = result.get("errorInfo", {})
        print(f"‚ùå Error: {error.get('description', 'Unknown error')}")
        print(f"   Code: {error.get('code')}")
        return
    
    if result.get("lookupResult") != 1:
        print(f"‚ùå No email found")
        if result.get("message"):
            print(f"   {result.get('message')}")
        return
    
    email = result.get("emailAddress", "N/A")
    match_type = result.get("matchType", "Unknown")
    validation = result.get("validationStatus", "Unknown")
    
    print(f"\nüìß {email}")
    print(f"   Match Type: {match_type}")
    print(f"   Validation: {validation}")
    
    if result.get("_match_type_requested"):
        print(f"   Query Type: {result.get('_match_type_requested')}")
    
    # Show validation results if we have them
    if validation_result and validation_result.get("status") == 0:
        print("\n   üìã Detailed Validation:")
        
        deliverability_labels = {
            0: "Unknown", 10: "Invalid", 20: "Undeliverable",
            30: "Risky", 40: "Valid", 45: "Not Verified", 50: "Deliverable"
        }
        
        domain_types = {
            0: "Unknown", 1: "Paid", 2: "Organization", 3: "Business",
            4: "Government", 5: "Educational", 6: "Wireless", 7: "Free", 8: "Disposable"
        }
        
        deliv = validation_result.get("deliverability", 0)
        domain = validation_result.get("domainType", 0)
        
        deliv_emoji = "‚úÖ" if deliv >= 40 else "‚ö†Ô∏è" if deliv >= 30 else "‚ùå"
        
        print(f"      {deliv_emoji} Deliverability: {deliverability_labels.get(deliv, deliv)}")
        print(f"      Domain Type: {domain_types.get(domain, domain)}")
        
        if validation_result.get("correctionCode") == 1:
            print(f"      üìù Corrected to: {validation_result.get('validatedEmail')}")


# =============================================================================
# MAIN
# =============================================================================

def main():
    parser = argparse.ArgumentParser(description="PacificEast Contact Enrichment Lookup")
    parser.add_argument("--key", "-k", help="PacificEast account key (or set PACIFICEAST_KEY env var)")
    parser.add_argument("--skip-dataprime", action="store_true", help="Skip DataPrime lookup")
    parser.add_argument("--skip-phone", action="store_true", help="Skip phone lookup")
    parser.add_argument("--skip-email", action="store_true", help="Skip email lookup")
    parser.add_argument("--json", action="store_true", help="Output raw JSON responses")
    args = parser.parse_args()
    
    # Get API key
    api_key = args.key or os.environ.get("PACIFICEAST_KEY")
    if not api_key:
        print("‚ùå Error: No API key provided")
        print("   Use --key YOUR_KEY or set PACIFICEAST_KEY environment variable")
        return 1
    
    print("="*70)
    print("PacificEast Contact Enrichment")
    print("="*70)
    print(f"\nüîç Looking up: {TARGET.first_name} {TARGET.last_name}")
    print(f"   Address: {TARGET.address}")
    print(f"   Location: {TARGET.city}, {TARGET.state} {TARGET.postal_code}")
    
    client = PacificEastClient(api_key)
    results = {}
    
    # Step 1: DataPrime - Verify address and identity
    if not args.skip_dataprime:
        print("\n" + "-"*70)
        print("Step 1: DataPrime Lookup")
        print("-"*70)
        results["dataprime"] = client.dataprime_lookup(TARGET)
        
        if args.json:
            print(json.dumps(results["dataprime"], indent=2))
        else:
            format_dataprime_result(results["dataprime"])
    
    # Step 2: Phone lookup with fallback strategies
    if not args.skip_phone:
        print("\n" + "-"*70)
        print("Step 2: Phone Number Lookup (with fallback strategies)")
        print("-"*70)
        results["phone"] = client.phone_lookup_with_fallback(TARGET)
        
        if args.json:
            print(json.dumps(results["phone"], indent=2))
        else:
            format_phone_result(results["phone"])
    
    # Step 3: Email lookup with fallback
    if not args.skip_email:
        print("\n" + "-"*70)
        print("Step 3: Email Lookup")
        print("-"*70)
        results["email"] = client.email_lookup_with_fallback(TARGET)
        
        # Step 4: Validate found email
        validation = None
        if results["email"].get("lookupResult") == 1 and results["email"].get("emailAddress"):
            print("\n  Validating found email...")
            validation = client.validate_email(results["email"]["emailAddress"])
            results["email_validation"] = validation
        
        if args.json:
            print(json.dumps(results["email"], indent=2))
            if validation:
                print(json.dumps(validation, indent=2))
        else:
            format_email_result(results["email"], validation)
    
    # Summary
    print("\n" + "="*70)
    print("SUMMARY")
    print("="*70)
    
    dp = results.get("dataprime", {})
    ph = results.get("phone", {})
    em = results.get("email", {})
    
    print(f"\nüë§ {TARGET.first_name} {TARGET.last_name}")
    
    if dp.get("lookupResult") == 1:
        print(f"   ‚úÖ Identity verified at address" if dp.get("verifiedIdentity") else "   ‚ö†Ô∏è  Identity not verified")
        if dp.get("knownDeceased"):
            print("   ‚ö†Ô∏è  KNOWN DECEASED")
    
    if ph.get("lookupResult") == 1:
        for c in ph.get("contacts", [])[:3]:
            phone = c.get("phoneInformation", {}).get("phoneNumber", "")
            if len(phone) == 10:
                phone = f"({phone[:3]}) {phone[3:6]}-{phone[6:]}"
            print(f"   üìû {phone}")
    else:
        print("   üìû No phone found")
    
    if em.get("lookupResult") == 1:
        print(f"   üìß {em.get('emailAddress')}")
    else:
        print("   üìß No email found")
    
    print()
    return 0


if __name__ == "__main__":
    exit(main())